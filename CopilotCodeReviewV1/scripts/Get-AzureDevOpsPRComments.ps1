<#
.SYNOPSIS
    Retrieves comments from a pull request in Azure DevOps, optionally filtering for Copilot-generated comments.

.DESCRIPTION
    This script uses the Azure DevOps REST API to retrieve comment threads from a pull request.
    It can filter for comments containing the "[Generated by GitHub Copilot]" tag and output
    them in a format suitable for processing by the code review workflow.

.PARAMETER Token
    Required. Authentication token for Azure DevOps. Can be a PAT or OAuth token.

.PARAMETER AuthType
    Optional. The type of authentication to use. Valid values: 'Basic' (for PAT) or 'Bearer' (for OAuth/System.AccessToken).
    Default is 'Basic'.

.PARAMETER Organization
    Required. The Azure DevOps organization name.

.PARAMETER Project
    Required. The Azure DevOps project name.

.PARAMETER Repository
    Required. The repository name where the pull request exists.

.PARAMETER Id
    Required. The pull request ID to retrieve comments from.

.PARAMETER CopilotOnly
    Optional. If specified, only returns comments that contain "[Generated by GitHub Copilot]" tag.

.PARAMETER OutputFile
    Optional. Output file path to write results to in a structured format.

.EXAMPLE
    .\Get-AzureDevOpsPRComments.ps1 -Token "your-pat" -Organization "myorg" -Project "myproject" -Repository "myrepo" -Id 123
    Retrieves all comments from pull request #123.

.EXAMPLE
    .\Get-AzureDevOpsPRComments.ps1 -Token "your-pat" -Organization "myorg" -Project "myproject" -Repository "myrepo" -Id 123 -CopilotOnly
    Retrieves only Copilot-generated comments from pull request #123.

.EXAMPLE
    .\Get-AzureDevOpsPRComments.ps1 -Token $env:AZUREDEVOPS_TOKEN -AuthType "Bearer" -Organization "myorg" -Project "myproject" -Repository "myrepo" -Id 123 -CopilotOnly -OutputFile "copilot-comments.txt"
    Retrieves Copilot comments and writes them to a file using OAuth authentication.

.NOTES
    Author: Little Fort Software
    Date: January 2026
    Requires: PowerShell 5.1 or later
#>

[CmdletBinding()]
param(
    [Parameter(Mandatory = $true, HelpMessage = "Authentication token for Azure DevOps (PAT or OAuth token)")]
    [ValidateNotNullOrEmpty()]
    [string]$Token,

    [Parameter(Mandatory = $false, HelpMessage = "Authentication type: 'Basic' for PAT, 'Bearer' for OAuth")]
    [ValidateSet("Basic", "Bearer")]
    [string]$AuthType = "Basic",

    [Parameter(Mandatory = $true, HelpMessage = "Azure DevOps organization name")]
    [ValidateNotNullOrEmpty()]
    [string]$Organization,

    [Parameter(Mandatory = $true, HelpMessage = "Azure DevOps project name")]
    [ValidateNotNullOrEmpty()]
    [string]$Project,

    [Parameter(Mandatory = $true, HelpMessage = "Repository name")]
    [ValidateNotNullOrEmpty()]
    [string]$Repository,

    [Parameter(Mandatory = $true, HelpMessage = "Pull request ID")]
    [ValidateRange(1, [int]::MaxValue)]
    [int]$Id,

    [Parameter(Mandatory = $false, HelpMessage = "Filter for Copilot-generated comments only")]
    [switch]$CopilotOnly,

    [Parameter(Mandatory = $false, HelpMessage = "Output file path to write results to")]
    [string]$OutputFile
)

#region Helper Functions

function Write-Output-Line {
    param(
        [string]$Message = "",
        [string]$ForegroundColor = "White",
        [switch]$NoNewline
    )
    
    if ($script:OutputToFile) {
        if ($NoNewline) {
            $script:OutputBuilder.Append($Message) | Out-Null
        }
        else {
            $script:OutputBuilder.AppendLine($Message) | Out-Null
        }
    }
    
    if ($NoNewline) {
        Write-Host $Message -ForegroundColor $ForegroundColor -NoNewline
    }
    else {
        Write-Host $Message -ForegroundColor $ForegroundColor
    }
}

function Get-AuthorizationHeader {
    param(
        [string]$Token,
        [string]$AuthType = "Basic"
    )
    
    if ($AuthType -eq "Bearer") {
        return @{
            Authorization  = "Bearer $Token"
            "Content-Type" = "application/json"
        }
    }
    else {
        $base64Auth = [Convert]::ToBase64String([Text.Encoding]::ASCII.GetBytes(":$Token"))
        return @{
            Authorization  = "Basic $base64Auth"
            "Content-Type" = "application/json"
        }
    }
}

function Invoke-AzureDevOpsApi {
    param(
        [string]$Uri,
        [hashtable]$Headers,
        [string]$Method = "Get",
        [object]$Body = $null
    )
    
    try {
        $params = @{
            Uri         = $Uri
            Headers     = $Headers
            Method      = $Method
            ErrorAction = "Stop"
        }
        
        if ($null -ne $Body) {
            $params.Body = $Body | ConvertTo-Json -Depth 10
        }
        
        $response = Invoke-RestMethod @params
        return $response
    }
    catch {
        $statusCode = $_.Exception.Response.StatusCode.value__
        $errorMessage = $_.ErrorDetails.Message
        
        if ($statusCode -eq 401) {
            Write-Error "Authentication failed. Please verify your token is valid and has appropriate permissions."
        }
        elseif ($statusCode -eq 404) {
            Write-Error "Resource not found. Please verify the organization, project, repository, and PR ID."
        }
        elseif ($statusCode -eq 400) {
            Write-Error "Bad request: $errorMessage"
        }
        else {
            Write-Error "API request failed: $errorMessage (Status: $statusCode)"
        }
        return $null
    }
}

function Format-DateForDisplay {
    param([string]$DateString)
    
    if ([string]::IsNullOrEmpty($DateString)) {
        return "N/A"
    }
    
    try {
        $date = [DateTime]::Parse($DateString)
        return $date.ToString("yyyy-MM-dd HH:mm")
    }
    catch {
        return $DateString
    }
}

#endregion

#region Main Logic

# Initialize output handling
$script:OutputToFile = -not [string]::IsNullOrEmpty($OutputFile)
$script:OutputBuilder = [System.Text.StringBuilder]::new()

$headers = Get-AuthorizationHeader -Token $Token -AuthType $AuthType
$baseUrl = "https://dev.azure.com/$Organization/$Project/_apis/git/repositories/$Repository/pullrequests/$Id"
$apiVersion = "api-version=7.1"

# Get PR threads (comments)
Write-Output-Line "`nRetrieving comments for Pull Request #$Id..." -ForegroundColor Cyan
$threadsUrl = "$baseUrl/threads?$apiVersion"
$threads = Invoke-AzureDevOpsApi -Uri $threadsUrl -Headers $headers

if ($null -eq $threads) {
    Write-Error "Failed to retrieve comments from pull request #$Id."
    exit 1
}

# Filter to actual comment threads (exclude system-generated threads)
$commentThreads = $threads.value | Where-Object { 
    $_.comments -and 
    $_.comments.Count -gt 0 -and 
    $_.comments[0].commentType -ne "system"
}

# Filter for Copilot-generated comments if requested
if ($CopilotOnly) {
    $commentThreads = $commentThreads | Where-Object {
        $firstComment = $_.comments | Select-Object -First 1
        $firstComment.content -like "*[Generated by GitHub Copilot]*"
    }
}

if ($commentThreads.Count -eq 0) {
    $filterMsg = if ($CopilotOnly) { "Copilot-generated comments" } else { "comments" }
    Write-Output-Line "`nNo $filterMsg found on pull request #$Id." -ForegroundColor Yellow
    exit 0
}

Write-Output-Line "`nFound $($commentThreads.Count) comment thread(s):`n" -ForegroundColor Green

# Display comments
Write-Output-Line ("=" * 80) -ForegroundColor DarkGray
Write-Output-Line "PULL REQUEST COMMENTS" -ForegroundColor Green
Write-Output-Line ("=" * 80) -ForegroundColor DarkGray

foreach ($thread in $commentThreads) {
    $firstComment = $thread.comments | Select-Object -First 1
    
    # Map thread status
    $threadStatus = switch ($thread.status) {
        "active"   { @{ Text = "Active"; Color = "Yellow" } }
        "fixed"    { @{ Text = "Fixed"; Color = "Green" } }
        "closed"   { @{ Text = "Closed"; Color = "Green" } }
        "wontFix"  { @{ Text = "Won't Fix"; Color = "DarkGray" } }
        "pending"  { @{ Text = "Pending"; Color = "Cyan" } }
        "byDesign" { @{ Text = "By Design"; Color = "DarkGray" } }
        default    { @{ Text = $thread.status; Color = "White" } }
    }
    
    Write-Output-Line ""
    Write-Output-Line "[Thread #$($thread.id)] - [$($threadStatus.Text)]" -ForegroundColor $threadStatus.Color
    
    # Show file context if this is a file-level comment
    if ($thread.threadContext -and $thread.threadContext.filePath) {
        $filePath = $thread.threadContext.filePath
        $lineInfo = ""
        if ($thread.threadContext.rightFileStart) {
            $lineInfo = " (Line $($thread.threadContext.rightFileStart.line))"
        }
        elseif ($thread.threadContext.leftFileStart) {
            $lineInfo = " (Line $($thread.threadContext.leftFileStart.line))"
        }
        Write-Output-Line "  File: $filePath$lineInfo" -ForegroundColor DarkCyan
    }
    
    Write-Output-Line "  Author: $($firstComment.author.displayName)" -ForegroundColor DarkGray
    Write-Output-Line "  Posted: $(Format-DateForDisplay $firstComment.publishedDate)" -ForegroundColor DarkGray
    
    # Display comment content
    $commentContent = $firstComment.content
    if (-not [string]::IsNullOrEmpty($commentContent)) {
        Write-Output-Line "`n  Content:" -ForegroundColor DarkGray
        $commentLines = $commentContent -split "`n"
        foreach ($line in $commentLines) {
            $trimmedLine = $line.TrimEnd()
            Write-Output-Line "    $trimmedLine"
        }
    }
    
    # Show reply count
    $replyCount = $thread.comments.Count - 1
    if ($replyCount -gt 0) {
        Write-Output-Line "`n  [$replyCount $(if ($replyCount -eq 1) { 'reply' } else { 'replies' })]" -ForegroundColor DarkGray
    }
    
    Write-Output-Line ("-" * 80) -ForegroundColor DarkGray
}

Write-Output-Line ""

# Summary
$activeCount = ($commentThreads | Where-Object { $_.status -eq "active" }).Count
$resolvedCount = ($commentThreads | Where-Object { $_.status -eq "fixed" -or $_.status -eq "closed" }).Count

Write-Output-Line "Summary:" -ForegroundColor Cyan
Write-Output-Line "  Total threads:    $($commentThreads.Count)"
Write-Output-Line "  Active threads:   $activeCount" -ForegroundColor $(if ($activeCount -gt 0) { "Yellow" } else { "Gray" })
Write-Output-Line "  Resolved threads: $resolvedCount" -ForegroundColor $(if ($resolvedCount -gt 0) { "Green" } else { "Gray" })

# Write to output file if specified
if ($script:OutputToFile) {
    try {
        $outputDir = Split-Path -Parent $OutputFile
        if (-not [string]::IsNullOrEmpty($outputDir) -and -not (Test-Path $outputDir)) {
            New-Item -ItemType Directory -Path $outputDir -Force | Out-Null
        }
        $script:OutputBuilder.ToString() | Out-File -FilePath $OutputFile -Encoding UTF8
        Write-Host "`nOutput written to: $OutputFile" -ForegroundColor Green
    }
    catch {
        Write-Error "Failed to write output file: $_"
    }
}

#endregion
